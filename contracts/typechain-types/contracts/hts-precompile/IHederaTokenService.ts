/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../common";

export declare namespace IHederaTokenService {
  export type KeyValueStruct = {
    inheritAccountKey: PromiseOrValue<boolean>;
    contractId: PromiseOrValue<string>;
    ed25519: PromiseOrValue<BytesLike>;
    ECDSA_secp256k1: PromiseOrValue<BytesLike>;
    delegatableContractId: PromiseOrValue<string>;
  };

  export type KeyValueStructOutput = [
    boolean,
    string,
    string,
    string,
    string
  ] & {
    inheritAccountKey: boolean;
    contractId: string;
    ed25519: string;
    ECDSA_secp256k1: string;
    delegatableContractId: string;
  };

  export type TokenKeyStruct = {
    keyType: PromiseOrValue<BigNumberish>;
    key: IHederaTokenService.KeyValueStruct;
  };

  export type TokenKeyStructOutput = [
    BigNumber,
    IHederaTokenService.KeyValueStructOutput
  ] & { keyType: BigNumber; key: IHederaTokenService.KeyValueStructOutput };

  export type ExpiryStruct = {
    second: PromiseOrValue<BigNumberish>;
    autoRenewAccount: PromiseOrValue<string>;
    autoRenewPeriod: PromiseOrValue<BigNumberish>;
  };

  export type ExpiryStructOutput = [number, string, number] & {
    second: number;
    autoRenewAccount: string;
    autoRenewPeriod: number;
  };

  export type HederaTokenStruct = {
    name: PromiseOrValue<string>;
    symbol: PromiseOrValue<string>;
    treasury: PromiseOrValue<string>;
    memo: PromiseOrValue<string>;
    tokenSupplyType: PromiseOrValue<boolean>;
    maxSupply: PromiseOrValue<BigNumberish>;
    freezeDefault: PromiseOrValue<boolean>;
    tokenKeys: IHederaTokenService.TokenKeyStruct[];
    expiry: IHederaTokenService.ExpiryStruct;
  };

  export type HederaTokenStructOutput = [
    string,
    string,
    string,
    string,
    boolean,
    BigNumber,
    boolean,
    IHederaTokenService.TokenKeyStructOutput[],
    IHederaTokenService.ExpiryStructOutput
  ] & {
    name: string;
    symbol: string;
    treasury: string;
    memo: string;
    tokenSupplyType: boolean;
    maxSupply: BigNumber;
    freezeDefault: boolean;
    tokenKeys: IHederaTokenService.TokenKeyStructOutput[];
    expiry: IHederaTokenService.ExpiryStructOutput;
  };

  export type FixedFeeStruct = {
    amount: PromiseOrValue<BigNumberish>;
    tokenId: PromiseOrValue<string>;
    useHbarsForPayment: PromiseOrValue<boolean>;
    useCurrentTokenForPayment: PromiseOrValue<boolean>;
    feeCollector: PromiseOrValue<string>;
  };

  export type FixedFeeStructOutput = [
    number,
    string,
    boolean,
    boolean,
    string
  ] & {
    amount: number;
    tokenId: string;
    useHbarsForPayment: boolean;
    useCurrentTokenForPayment: boolean;
    feeCollector: string;
  };

  export type FractionalFeeStruct = {
    numerator: PromiseOrValue<BigNumberish>;
    denominator: PromiseOrValue<BigNumberish>;
    minimumAmount: PromiseOrValue<BigNumberish>;
    maximumAmount: PromiseOrValue<BigNumberish>;
    netOfTransfers: PromiseOrValue<boolean>;
    feeCollector: PromiseOrValue<string>;
  };

  export type FractionalFeeStructOutput = [
    number,
    number,
    number,
    number,
    boolean,
    string
  ] & {
    numerator: number;
    denominator: number;
    minimumAmount: number;
    maximumAmount: number;
    netOfTransfers: boolean;
    feeCollector: string;
  };

  export type RoyaltyFeeStruct = {
    numerator: PromiseOrValue<BigNumberish>;
    denominator: PromiseOrValue<BigNumberish>;
    amount: PromiseOrValue<BigNumberish>;
    tokenId: PromiseOrValue<string>;
    useHbarsForPayment: PromiseOrValue<boolean>;
    feeCollector: PromiseOrValue<string>;
  };

  export type RoyaltyFeeStructOutput = [
    number,
    number,
    number,
    string,
    boolean,
    string
  ] & {
    numerator: number;
    denominator: number;
    amount: number;
    tokenId: string;
    useHbarsForPayment: boolean;
    feeCollector: string;
  };

  export type AccountAmountStruct = {
    accountID: PromiseOrValue<string>;
    amount: PromiseOrValue<BigNumberish>;
    isApproval: PromiseOrValue<boolean>;
  };

  export type AccountAmountStructOutput = [string, BigNumber, boolean] & {
    accountID: string;
    amount: BigNumber;
    isApproval: boolean;
  };

  export type TransferListStruct = {
    transfers: IHederaTokenService.AccountAmountStruct[];
  };

  export type TransferListStructOutput = [
    IHederaTokenService.AccountAmountStructOutput[]
  ] & { transfers: IHederaTokenService.AccountAmountStructOutput[] };

  export type NftTransferStruct = {
    senderAccountID: PromiseOrValue<string>;
    receiverAccountID: PromiseOrValue<string>;
    serialNumber: PromiseOrValue<BigNumberish>;
    isApproval: PromiseOrValue<boolean>;
  };

  export type NftTransferStructOutput = [string, string, BigNumber, boolean] & {
    senderAccountID: string;
    receiverAccountID: string;
    serialNumber: BigNumber;
    isApproval: boolean;
  };

  export type TokenTransferListStruct = {
    token: PromiseOrValue<string>;
    transfers: IHederaTokenService.AccountAmountStruct[];
    nftTransfers: IHederaTokenService.NftTransferStruct[];
  };

  export type TokenTransferListStructOutput = [
    string,
    IHederaTokenService.AccountAmountStructOutput[],
    IHederaTokenService.NftTransferStructOutput[]
  ] & {
    token: string;
    transfers: IHederaTokenService.AccountAmountStructOutput[];
    nftTransfers: IHederaTokenService.NftTransferStructOutput[];
  };

  export type TokenInfoStruct = {
    token: IHederaTokenService.HederaTokenStruct;
    totalSupply: PromiseOrValue<BigNumberish>;
    deleted: PromiseOrValue<boolean>;
    defaultKycStatus: PromiseOrValue<boolean>;
    pauseStatus: PromiseOrValue<boolean>;
    fixedFees: IHederaTokenService.FixedFeeStruct[];
    fractionalFees: IHederaTokenService.FractionalFeeStruct[];
    royaltyFees: IHederaTokenService.RoyaltyFeeStruct[];
    ledgerId: PromiseOrValue<string>;
  };

  export type TokenInfoStructOutput = [
    IHederaTokenService.HederaTokenStructOutput,
    BigNumber,
    boolean,
    boolean,
    boolean,
    IHederaTokenService.FixedFeeStructOutput[],
    IHederaTokenService.FractionalFeeStructOutput[],
    IHederaTokenService.RoyaltyFeeStructOutput[],
    string
  ] & {
    token: IHederaTokenService.HederaTokenStructOutput;
    totalSupply: BigNumber;
    deleted: boolean;
    defaultKycStatus: boolean;
    pauseStatus: boolean;
    fixedFees: IHederaTokenService.FixedFeeStructOutput[];
    fractionalFees: IHederaTokenService.FractionalFeeStructOutput[];
    royaltyFees: IHederaTokenService.RoyaltyFeeStructOutput[];
    ledgerId: string;
  };

  export type FungibleTokenInfoStruct = {
    tokenInfo: IHederaTokenService.TokenInfoStruct;
    decimals: PromiseOrValue<BigNumberish>;
  };

  export type FungibleTokenInfoStructOutput = [
    IHederaTokenService.TokenInfoStructOutput,
    number
  ] & {
    tokenInfo: IHederaTokenService.TokenInfoStructOutput;
    decimals: number;
  };

  export type NonFungibleTokenInfoStruct = {
    tokenInfo: IHederaTokenService.TokenInfoStruct;
    serialNumber: PromiseOrValue<BigNumberish>;
    ownerId: PromiseOrValue<string>;
    creationTime: PromiseOrValue<BigNumberish>;
    metadata: PromiseOrValue<BytesLike>;
    spenderId: PromiseOrValue<string>;
  };

  export type NonFungibleTokenInfoStructOutput = [
    IHederaTokenService.TokenInfoStructOutput,
    BigNumber,
    string,
    BigNumber,
    string,
    string
  ] & {
    tokenInfo: IHederaTokenService.TokenInfoStructOutput;
    serialNumber: BigNumber;
    ownerId: string;
    creationTime: BigNumber;
    metadata: string;
    spenderId: string;
  };
}

export interface IHederaTokenServiceInterface extends utils.Interface {
  functions: {
    "allowance(address,address,address)": FunctionFragment;
    "approve(address,address,uint256)": FunctionFragment;
    "approveNFT(address,address,uint256)": FunctionFragment;
    "associateToken(address,address)": FunctionFragment;
    "associateTokens(address,address[])": FunctionFragment;
    "burnToken(address,uint64,int64[])": FunctionFragment;
    "createFungibleToken((string,string,address,string,bool,int64,bool,(uint256,(bool,address,bytes,bytes,address))[],(uint32,address,uint32)),uint64,uint32)": FunctionFragment;
    "createFungibleTokenWithCustomFees((string,string,address,string,bool,int64,bool,(uint256,(bool,address,bytes,bytes,address))[],(uint32,address,uint32)),uint64,uint32,(uint32,address,bool,bool,address)[],(uint32,uint32,uint32,uint32,bool,address)[])": FunctionFragment;
    "createNonFungibleToken((string,string,address,string,bool,int64,bool,(uint256,(bool,address,bytes,bytes,address))[],(uint32,address,uint32)))": FunctionFragment;
    "createNonFungibleTokenWithCustomFees((string,string,address,string,bool,int64,bool,(uint256,(bool,address,bytes,bytes,address))[],(uint32,address,uint32)),(uint32,address,bool,bool,address)[],(uint32,uint32,uint32,address,bool,address)[])": FunctionFragment;
    "cryptoTransfer(((address,int64,bool)[]),(address,(address,int64,bool)[],(address,address,int64,bool)[])[])": FunctionFragment;
    "deleteToken(address)": FunctionFragment;
    "dissociateToken(address,address)": FunctionFragment;
    "dissociateTokens(address,address[])": FunctionFragment;
    "freezeToken(address,address)": FunctionFragment;
    "getApproved(address,uint256)": FunctionFragment;
    "getFungibleTokenInfo(address)": FunctionFragment;
    "getNonFungibleTokenInfo(address,int64)": FunctionFragment;
    "getTokenCustomFees(address)": FunctionFragment;
    "getTokenDefaultFreezeStatus(address)": FunctionFragment;
    "getTokenDefaultKycStatus(address)": FunctionFragment;
    "getTokenExpiryInfo(address)": FunctionFragment;
    "getTokenInfo(address)": FunctionFragment;
    "getTokenKey(address,uint256)": FunctionFragment;
    "getTokenType(address)": FunctionFragment;
    "grantTokenKyc(address,address)": FunctionFragment;
    "isApprovedForAll(address,address,address)": FunctionFragment;
    "isFrozen(address,address)": FunctionFragment;
    "isKyc(address,address)": FunctionFragment;
    "isToken(address)": FunctionFragment;
    "mintToken(address,uint64,bytes[])": FunctionFragment;
    "pauseToken(address)": FunctionFragment;
    "revokeTokenKyc(address,address)": FunctionFragment;
    "setApprovalForAll(address,address,bool)": FunctionFragment;
    "transferFrom(address,address,address,uint256)": FunctionFragment;
    "transferFromNFT(address,address,address,uint256)": FunctionFragment;
    "transferNFT(address,address,address,int64)": FunctionFragment;
    "transferNFTs(address,address[],address[],int64[])": FunctionFragment;
    "transferToken(address,address,address,int64)": FunctionFragment;
    "transferTokens(address,address[],int64[])": FunctionFragment;
    "unfreezeToken(address,address)": FunctionFragment;
    "unpauseToken(address)": FunctionFragment;
    "updateTokenExpiryInfo(address,(uint32,address,uint32))": FunctionFragment;
    "updateTokenInfo(address,(string,string,address,string,bool,int64,bool,(uint256,(bool,address,bytes,bytes,address))[],(uint32,address,uint32)))": FunctionFragment;
    "updateTokenKeys(address,(uint256,(bool,address,bytes,bytes,address))[])": FunctionFragment;
    "wipeTokenAccount(address,address,uint32)": FunctionFragment;
    "wipeTokenAccountNFT(address,address,int64[])": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "allowance"
      | "approve"
      | "approveNFT"
      | "associateToken"
      | "associateTokens"
      | "burnToken"
      | "createFungibleToken"
      | "createFungibleTokenWithCustomFees"
      | "createNonFungibleToken"
      | "createNonFungibleTokenWithCustomFees"
      | "cryptoTransfer"
      | "deleteToken"
      | "dissociateToken"
      | "dissociateTokens"
      | "freezeToken"
      | "getApproved"
      | "getFungibleTokenInfo"
      | "getNonFungibleTokenInfo"
      | "getTokenCustomFees"
      | "getTokenDefaultFreezeStatus"
      | "getTokenDefaultKycStatus"
      | "getTokenExpiryInfo"
      | "getTokenInfo"
      | "getTokenKey"
      | "getTokenType"
      | "grantTokenKyc"
      | "isApprovedForAll"
      | "isFrozen"
      | "isKyc"
      | "isToken"
      | "mintToken"
      | "pauseToken"
      | "revokeTokenKyc"
      | "setApprovalForAll"
      | "transferFrom"
      | "transferFromNFT"
      | "transferNFT"
      | "transferNFTs"
      | "transferToken"
      | "transferTokens"
      | "unfreezeToken"
      | "unpauseToken"
      | "updateTokenExpiryInfo"
      | "updateTokenInfo"
      | "updateTokenKeys"
      | "wipeTokenAccount"
      | "wipeTokenAccountNFT"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "allowance",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "approve",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "approveNFT",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "associateToken",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "associateTokens",
    values: [PromiseOrValue<string>, PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "burnToken",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createFungibleToken",
    values: [
      IHederaTokenService.HederaTokenStruct,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createFungibleTokenWithCustomFees",
    values: [
      IHederaTokenService.HederaTokenStruct,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      IHederaTokenService.FixedFeeStruct[],
      IHederaTokenService.FractionalFeeStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createNonFungibleToken",
    values: [IHederaTokenService.HederaTokenStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "createNonFungibleTokenWithCustomFees",
    values: [
      IHederaTokenService.HederaTokenStruct,
      IHederaTokenService.FixedFeeStruct[],
      IHederaTokenService.RoyaltyFeeStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "cryptoTransfer",
    values: [
      IHederaTokenService.TransferListStruct,
      IHederaTokenService.TokenTransferListStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "deleteToken",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "dissociateToken",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "dissociateTokens",
    values: [PromiseOrValue<string>, PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "freezeToken",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getApproved",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getFungibleTokenInfo",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNonFungibleTokenInfo",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenCustomFees",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenDefaultFreezeStatus",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenDefaultKycStatus",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenExpiryInfo",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenInfo",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenKey",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenType",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "grantTokenKyc",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isApprovedForAll",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isFrozen",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isKyc",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isToken",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "mintToken",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "pauseToken",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "revokeTokenKyc",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setApprovalForAll",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFrom",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFromNFT",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "transferNFT",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "transferNFTs",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>[],
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "transferToken",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "transferTokens",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "unfreezeToken",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "unpauseToken",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateTokenExpiryInfo",
    values: [PromiseOrValue<string>, IHederaTokenService.ExpiryStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "updateTokenInfo",
    values: [PromiseOrValue<string>, IHederaTokenService.HederaTokenStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "updateTokenKeys",
    values: [PromiseOrValue<string>, IHederaTokenService.TokenKeyStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "wipeTokenAccount",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "wipeTokenAccountNFT",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;

  decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "approveNFT", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "associateToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "associateTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "burnToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "createFungibleToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createFungibleTokenWithCustomFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createNonFungibleToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createNonFungibleTokenWithCustomFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cryptoTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deleteToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "dissociateToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "dissociateTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "freezeToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getApproved",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFungibleTokenInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNonFungibleTokenInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenCustomFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenDefaultFreezeStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenDefaultKycStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenExpiryInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenKey",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenType",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "grantTokenKyc",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isApprovedForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isFrozen", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isKyc", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isToken", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "mintToken", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pauseToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "revokeTokenKyc",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setApprovalForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferFromNFT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferNFT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferNFTs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unfreezeToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unpauseToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateTokenExpiryInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateTokenInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateTokenKeys",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "wipeTokenAccount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "wipeTokenAccountNFT",
    data: BytesLike
  ): Result;

  events: {};
}

export interface IHederaTokenService extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: IHederaTokenServiceInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    allowance(
      token: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    approve(
      token: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    approveNFT(
      token: PromiseOrValue<string>,
      approved: PromiseOrValue<string>,
      serialNumber: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    associateToken(
      account: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    associateTokens(
      account: PromiseOrValue<string>,
      tokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    burnToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      serialNumbers: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createFungibleToken(
      token: IHederaTokenService.HederaTokenStruct,
      initialTotalSupply: PromiseOrValue<BigNumberish>,
      decimals: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createFungibleTokenWithCustomFees(
      token: IHederaTokenService.HederaTokenStruct,
      initialTotalSupply: PromiseOrValue<BigNumberish>,
      decimals: PromiseOrValue<BigNumberish>,
      fixedFees: IHederaTokenService.FixedFeeStruct[],
      fractionalFees: IHederaTokenService.FractionalFeeStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createNonFungibleToken(
      token: IHederaTokenService.HederaTokenStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createNonFungibleTokenWithCustomFees(
      token: IHederaTokenService.HederaTokenStruct,
      fixedFees: IHederaTokenService.FixedFeeStruct[],
      royaltyFees: IHederaTokenService.RoyaltyFeeStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    cryptoTransfer(
      transferList: IHederaTokenService.TransferListStruct,
      tokenTransfers: IHederaTokenService.TokenTransferListStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    deleteToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    dissociateToken(
      account: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    dissociateTokens(
      account: PromiseOrValue<string>,
      tokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    freezeToken(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getApproved(
      token: PromiseOrValue<string>,
      serialNumber: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getFungibleTokenInfo(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getNonFungibleTokenInfo(
      token: PromiseOrValue<string>,
      serialNumber: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getTokenCustomFees(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getTokenDefaultFreezeStatus(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getTokenDefaultKycStatus(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getTokenExpiryInfo(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getTokenInfo(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getTokenKey(
      token: PromiseOrValue<string>,
      keyType: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getTokenType(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    grantTokenKyc(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isApprovedForAll(
      token: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isFrozen(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isKyc(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    mintToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      metadata: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    pauseToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    revokeTokenKyc(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setApprovalForAll(
      token: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transferFrom(
      token: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transferFromNFT(
      token: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      serialNumber: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transferNFT(
      token: PromiseOrValue<string>,
      sender: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      serialNumber: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transferNFTs(
      token: PromiseOrValue<string>,
      sender: PromiseOrValue<string>[],
      receiver: PromiseOrValue<string>[],
      serialNumber: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transferToken(
      token: PromiseOrValue<string>,
      sender: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transferTokens(
      token: PromiseOrValue<string>,
      accountId: PromiseOrValue<string>[],
      amount: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    unfreezeToken(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    unpauseToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateTokenExpiryInfo(
      token: PromiseOrValue<string>,
      expiryInfo: IHederaTokenService.ExpiryStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateTokenInfo(
      token: PromiseOrValue<string>,
      tokenInfo: IHederaTokenService.HederaTokenStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateTokenKeys(
      token: PromiseOrValue<string>,
      keys: IHederaTokenService.TokenKeyStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    wipeTokenAccount(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    wipeTokenAccountNFT(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      serialNumbers: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  allowance(
    token: PromiseOrValue<string>,
    owner: PromiseOrValue<string>,
    spender: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  approve(
    token: PromiseOrValue<string>,
    spender: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  approveNFT(
    token: PromiseOrValue<string>,
    approved: PromiseOrValue<string>,
    serialNumber: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  associateToken(
    account: PromiseOrValue<string>,
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  associateTokens(
    account: PromiseOrValue<string>,
    tokens: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  burnToken(
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    serialNumbers: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createFungibleToken(
    token: IHederaTokenService.HederaTokenStruct,
    initialTotalSupply: PromiseOrValue<BigNumberish>,
    decimals: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createFungibleTokenWithCustomFees(
    token: IHederaTokenService.HederaTokenStruct,
    initialTotalSupply: PromiseOrValue<BigNumberish>,
    decimals: PromiseOrValue<BigNumberish>,
    fixedFees: IHederaTokenService.FixedFeeStruct[],
    fractionalFees: IHederaTokenService.FractionalFeeStruct[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createNonFungibleToken(
    token: IHederaTokenService.HederaTokenStruct,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createNonFungibleTokenWithCustomFees(
    token: IHederaTokenService.HederaTokenStruct,
    fixedFees: IHederaTokenService.FixedFeeStruct[],
    royaltyFees: IHederaTokenService.RoyaltyFeeStruct[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  cryptoTransfer(
    transferList: IHederaTokenService.TransferListStruct,
    tokenTransfers: IHederaTokenService.TokenTransferListStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  deleteToken(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  dissociateToken(
    account: PromiseOrValue<string>,
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  dissociateTokens(
    account: PromiseOrValue<string>,
    tokens: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  freezeToken(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getApproved(
    token: PromiseOrValue<string>,
    serialNumber: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getFungibleTokenInfo(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getNonFungibleTokenInfo(
    token: PromiseOrValue<string>,
    serialNumber: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getTokenCustomFees(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getTokenDefaultFreezeStatus(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getTokenDefaultKycStatus(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getTokenExpiryInfo(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getTokenInfo(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getTokenKey(
    token: PromiseOrValue<string>,
    keyType: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getTokenType(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  grantTokenKyc(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isApprovedForAll(
    token: PromiseOrValue<string>,
    owner: PromiseOrValue<string>,
    operator: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isFrozen(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isKyc(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isToken(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  mintToken(
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    metadata: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  pauseToken(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  revokeTokenKyc(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setApprovalForAll(
    token: PromiseOrValue<string>,
    operator: PromiseOrValue<string>,
    approved: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  transferFrom(
    token: PromiseOrValue<string>,
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  transferFromNFT(
    token: PromiseOrValue<string>,
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    serialNumber: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  transferNFT(
    token: PromiseOrValue<string>,
    sender: PromiseOrValue<string>,
    recipient: PromiseOrValue<string>,
    serialNumber: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  transferNFTs(
    token: PromiseOrValue<string>,
    sender: PromiseOrValue<string>[],
    receiver: PromiseOrValue<string>[],
    serialNumber: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  transferToken(
    token: PromiseOrValue<string>,
    sender: PromiseOrValue<string>,
    recipient: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  transferTokens(
    token: PromiseOrValue<string>,
    accountId: PromiseOrValue<string>[],
    amount: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  unfreezeToken(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  unpauseToken(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateTokenExpiryInfo(
    token: PromiseOrValue<string>,
    expiryInfo: IHederaTokenService.ExpiryStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateTokenInfo(
    token: PromiseOrValue<string>,
    tokenInfo: IHederaTokenService.HederaTokenStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateTokenKeys(
    token: PromiseOrValue<string>,
    keys: IHederaTokenService.TokenKeyStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  wipeTokenAccount(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  wipeTokenAccountNFT(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    serialNumbers: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    allowance(
      token: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { responseCode: BigNumber; allowance: BigNumber }
    >;

    approve(
      token: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    approveNFT(
      token: PromiseOrValue<string>,
      approved: PromiseOrValue<string>,
      serialNumber: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    associateToken(
      account: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    associateTokens(
      account: PromiseOrValue<string>,
      tokens: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    burnToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      serialNumbers: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        responseCode: BigNumber;
        newTotalSupply: BigNumber;
      }
    >;

    createFungibleToken(
      token: IHederaTokenService.HederaTokenStruct,
      initialTotalSupply: PromiseOrValue<BigNumberish>,
      decimals: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string] & { responseCode: BigNumber; tokenAddress: string }
    >;

    createFungibleTokenWithCustomFees(
      token: IHederaTokenService.HederaTokenStruct,
      initialTotalSupply: PromiseOrValue<BigNumberish>,
      decimals: PromiseOrValue<BigNumberish>,
      fixedFees: IHederaTokenService.FixedFeeStruct[],
      fractionalFees: IHederaTokenService.FractionalFeeStruct[],
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string] & { responseCode: BigNumber; tokenAddress: string }
    >;

    createNonFungibleToken(
      token: IHederaTokenService.HederaTokenStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string] & { responseCode: BigNumber; tokenAddress: string }
    >;

    createNonFungibleTokenWithCustomFees(
      token: IHederaTokenService.HederaTokenStruct,
      fixedFees: IHederaTokenService.FixedFeeStruct[],
      royaltyFees: IHederaTokenService.RoyaltyFeeStruct[],
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string] & { responseCode: BigNumber; tokenAddress: string }
    >;

    cryptoTransfer(
      transferList: IHederaTokenService.TransferListStruct,
      tokenTransfers: IHederaTokenService.TokenTransferListStruct[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    deleteToken(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    dissociateToken(
      account: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    dissociateTokens(
      account: PromiseOrValue<string>,
      tokens: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    freezeToken(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getApproved(
      token: PromiseOrValue<string>,
      serialNumber: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string] & { responseCode: BigNumber; approved: string }
    >;

    getFungibleTokenInfo(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, IHederaTokenService.FungibleTokenInfoStructOutput] & {
        responseCode: BigNumber;
        fungibleTokenInfo: IHederaTokenService.FungibleTokenInfoStructOutput;
      }
    >;

    getNonFungibleTokenInfo(
      token: PromiseOrValue<string>,
      serialNumber: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, IHederaTokenService.NonFungibleTokenInfoStructOutput] & {
        responseCode: BigNumber;
        nonFungibleTokenInfo: IHederaTokenService.NonFungibleTokenInfoStructOutput;
      }
    >;

    getTokenCustomFees(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        IHederaTokenService.FixedFeeStructOutput[],
        IHederaTokenService.FractionalFeeStructOutput[],
        IHederaTokenService.RoyaltyFeeStructOutput[]
      ] & {
        responseCode: BigNumber;
        fixedFees: IHederaTokenService.FixedFeeStructOutput[];
        fractionalFees: IHederaTokenService.FractionalFeeStructOutput[];
        royaltyFees: IHederaTokenService.RoyaltyFeeStructOutput[];
      }
    >;

    getTokenDefaultFreezeStatus(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean] & {
        responseCode: BigNumber;
        defaultFreezeStatus: boolean;
      }
    >;

    getTokenDefaultKycStatus(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean] & {
        responseCode: BigNumber;
        defaultKycStatus: boolean;
      }
    >;

    getTokenExpiryInfo(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, IHederaTokenService.ExpiryStructOutput] & {
        responseCode: BigNumber;
        expiry: IHederaTokenService.ExpiryStructOutput;
      }
    >;

    getTokenInfo(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, IHederaTokenService.TokenInfoStructOutput] & {
        responseCode: BigNumber;
        tokenInfo: IHederaTokenService.TokenInfoStructOutput;
      }
    >;

    getTokenKey(
      token: PromiseOrValue<string>,
      keyType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, IHederaTokenService.KeyValueStructOutput] & {
        responseCode: BigNumber;
        key: IHederaTokenService.KeyValueStructOutput;
      }
    >;

    getTokenType(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, number] & { responseCode: BigNumber; tokenType: number }
    >;

    grantTokenKyc(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isApprovedForAll(
      token: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean] & { responseCode: BigNumber; approved: boolean }
    >;

    isFrozen(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean] & { responseCode: BigNumber; frozen: boolean }
    >;

    isKyc(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean] & { responseCode: BigNumber; kycGranted: boolean }
    >;

    isToken(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean] & { responseCode: BigNumber; isToken: boolean }
    >;

    mintToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      metadata: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber[]] & {
        responseCode: BigNumber;
        newTotalSupply: BigNumber;
        serialNumbers: BigNumber[];
      }
    >;

    pauseToken(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    revokeTokenKyc(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setApprovalForAll(
      token: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferFrom(
      token: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferFromNFT(
      token: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      serialNumber: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferNFT(
      token: PromiseOrValue<string>,
      sender: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      serialNumber: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferNFTs(
      token: PromiseOrValue<string>,
      sender: PromiseOrValue<string>[],
      receiver: PromiseOrValue<string>[],
      serialNumber: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferToken(
      token: PromiseOrValue<string>,
      sender: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferTokens(
      token: PromiseOrValue<string>,
      accountId: PromiseOrValue<string>[],
      amount: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    unfreezeToken(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    unpauseToken(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    updateTokenExpiryInfo(
      token: PromiseOrValue<string>,
      expiryInfo: IHederaTokenService.ExpiryStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    updateTokenInfo(
      token: PromiseOrValue<string>,
      tokenInfo: IHederaTokenService.HederaTokenStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    updateTokenKeys(
      token: PromiseOrValue<string>,
      keys: IHederaTokenService.TokenKeyStruct[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    wipeTokenAccount(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    wipeTokenAccountNFT(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      serialNumbers: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  filters: {};

  estimateGas: {
    allowance(
      token: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    approve(
      token: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    approveNFT(
      token: PromiseOrValue<string>,
      approved: PromiseOrValue<string>,
      serialNumber: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    associateToken(
      account: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    associateTokens(
      account: PromiseOrValue<string>,
      tokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    burnToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      serialNumbers: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createFungibleToken(
      token: IHederaTokenService.HederaTokenStruct,
      initialTotalSupply: PromiseOrValue<BigNumberish>,
      decimals: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createFungibleTokenWithCustomFees(
      token: IHederaTokenService.HederaTokenStruct,
      initialTotalSupply: PromiseOrValue<BigNumberish>,
      decimals: PromiseOrValue<BigNumberish>,
      fixedFees: IHederaTokenService.FixedFeeStruct[],
      fractionalFees: IHederaTokenService.FractionalFeeStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createNonFungibleToken(
      token: IHederaTokenService.HederaTokenStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createNonFungibleTokenWithCustomFees(
      token: IHederaTokenService.HederaTokenStruct,
      fixedFees: IHederaTokenService.FixedFeeStruct[],
      royaltyFees: IHederaTokenService.RoyaltyFeeStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    cryptoTransfer(
      transferList: IHederaTokenService.TransferListStruct,
      tokenTransfers: IHederaTokenService.TokenTransferListStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    deleteToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    dissociateToken(
      account: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    dissociateTokens(
      account: PromiseOrValue<string>,
      tokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    freezeToken(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getApproved(
      token: PromiseOrValue<string>,
      serialNumber: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getFungibleTokenInfo(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getNonFungibleTokenInfo(
      token: PromiseOrValue<string>,
      serialNumber: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getTokenCustomFees(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getTokenDefaultFreezeStatus(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getTokenDefaultKycStatus(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getTokenExpiryInfo(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getTokenInfo(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getTokenKey(
      token: PromiseOrValue<string>,
      keyType: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getTokenType(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    grantTokenKyc(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isApprovedForAll(
      token: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isFrozen(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isKyc(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    mintToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      metadata: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    pauseToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    revokeTokenKyc(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setApprovalForAll(
      token: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    transferFrom(
      token: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    transferFromNFT(
      token: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      serialNumber: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    transferNFT(
      token: PromiseOrValue<string>,
      sender: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      serialNumber: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    transferNFTs(
      token: PromiseOrValue<string>,
      sender: PromiseOrValue<string>[],
      receiver: PromiseOrValue<string>[],
      serialNumber: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    transferToken(
      token: PromiseOrValue<string>,
      sender: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    transferTokens(
      token: PromiseOrValue<string>,
      accountId: PromiseOrValue<string>[],
      amount: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    unfreezeToken(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    unpauseToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateTokenExpiryInfo(
      token: PromiseOrValue<string>,
      expiryInfo: IHederaTokenService.ExpiryStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateTokenInfo(
      token: PromiseOrValue<string>,
      tokenInfo: IHederaTokenService.HederaTokenStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateTokenKeys(
      token: PromiseOrValue<string>,
      keys: IHederaTokenService.TokenKeyStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    wipeTokenAccount(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    wipeTokenAccountNFT(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      serialNumbers: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    allowance(
      token: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    approve(
      token: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    approveNFT(
      token: PromiseOrValue<string>,
      approved: PromiseOrValue<string>,
      serialNumber: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    associateToken(
      account: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    associateTokens(
      account: PromiseOrValue<string>,
      tokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    burnToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      serialNumbers: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createFungibleToken(
      token: IHederaTokenService.HederaTokenStruct,
      initialTotalSupply: PromiseOrValue<BigNumberish>,
      decimals: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createFungibleTokenWithCustomFees(
      token: IHederaTokenService.HederaTokenStruct,
      initialTotalSupply: PromiseOrValue<BigNumberish>,
      decimals: PromiseOrValue<BigNumberish>,
      fixedFees: IHederaTokenService.FixedFeeStruct[],
      fractionalFees: IHederaTokenService.FractionalFeeStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createNonFungibleToken(
      token: IHederaTokenService.HederaTokenStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createNonFungibleTokenWithCustomFees(
      token: IHederaTokenService.HederaTokenStruct,
      fixedFees: IHederaTokenService.FixedFeeStruct[],
      royaltyFees: IHederaTokenService.RoyaltyFeeStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    cryptoTransfer(
      transferList: IHederaTokenService.TransferListStruct,
      tokenTransfers: IHederaTokenService.TokenTransferListStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    deleteToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    dissociateToken(
      account: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    dissociateTokens(
      account: PromiseOrValue<string>,
      tokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    freezeToken(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getApproved(
      token: PromiseOrValue<string>,
      serialNumber: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getFungibleTokenInfo(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getNonFungibleTokenInfo(
      token: PromiseOrValue<string>,
      serialNumber: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getTokenCustomFees(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getTokenDefaultFreezeStatus(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getTokenDefaultKycStatus(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getTokenExpiryInfo(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getTokenInfo(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getTokenKey(
      token: PromiseOrValue<string>,
      keyType: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getTokenType(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    grantTokenKyc(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isApprovedForAll(
      token: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isFrozen(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isKyc(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    mintToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      metadata: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    pauseToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    revokeTokenKyc(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setApprovalForAll(
      token: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    transferFrom(
      token: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    transferFromNFT(
      token: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      serialNumber: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    transferNFT(
      token: PromiseOrValue<string>,
      sender: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      serialNumber: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    transferNFTs(
      token: PromiseOrValue<string>,
      sender: PromiseOrValue<string>[],
      receiver: PromiseOrValue<string>[],
      serialNumber: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    transferToken(
      token: PromiseOrValue<string>,
      sender: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    transferTokens(
      token: PromiseOrValue<string>,
      accountId: PromiseOrValue<string>[],
      amount: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    unfreezeToken(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    unpauseToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateTokenExpiryInfo(
      token: PromiseOrValue<string>,
      expiryInfo: IHederaTokenService.ExpiryStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateTokenInfo(
      token: PromiseOrValue<string>,
      tokenInfo: IHederaTokenService.HederaTokenStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateTokenKeys(
      token: PromiseOrValue<string>,
      keys: IHederaTokenService.TokenKeyStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    wipeTokenAccount(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    wipeTokenAccountNFT(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      serialNumbers: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
