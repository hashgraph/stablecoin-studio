# app.py
import io
from typing import Dict, Tuple, Optional, List

import numpy as np
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import streamlit as st

# ======================
# Constants & Styles
# ======================
TZ = "Indian/Antananarivo"

TX_TYPES = [
    "P2P_IN", "P2P_IN_INTL", "CASHIN", "B2W",
    "P2P_OUT", "MERCHANT", "AIRTIME", "OTP", "FAIL", "OTHER"
]
TX_COLORS = {
    "P2P_IN":      "#28a745",
    "P2P_IN_INTL": "#66bb6a",
    "CASHIN":      "#1b5e20",
    "B2W":         "#2ecc71",
    "P2P_OUT":     "#ff9800",
    "MERCHANT":    "#ef6c00",
    "AIRTIME":     "#2196f3",
    "OTP":         "#bdbdbd",
    "FAIL":        "#e53935",
    "OTHER":       "#9c27b0"
}
COLOR_EMPTY = "#eeeeee"
GREEN_IN = "#2ECC71"
RED_OUT  = "#E53935"

IN_TYPES  = {"P2P_IN", "P2P_IN_INTL", "CASHIN", "B2W"}
OUT_TYPES = {"P2P_OUT", "MERCHANT", "AIRTIME"}

# ======================
# I/O
# ======================
def read_csv_smart(file) -> pd.DataFrame:
    """Robust CSV read with simple separator detection."""
    raw = file.read()
    try:
        content = raw.decode("utf-8-sig")
    except Exception:
        content = raw.decode("utf-8", errors="ignore")
    sep_candidates = [",", ";", "\t", "|"]
    counts = {s: content.count(s) for s in sep_candidates}
    sep = max(counts, key=counts.get) if max(counts.values()) > 0 else ","
    return pd.read_csv(io.StringIO(content), sep=sep)

# ======================
# Processing
# ======================
def map_freq_label(freq_label: str) -> str:
    return {"15min": "15min", "30min": "30min", "1H": "H", "6H": "6H", "1D": "D"}[freq_label]

def _parse_timestamp_series(ts_raw: pd.Series) -> pd.Series:
    """Parse timestamps to tz-aware (Antananarivo). Localize if naive, convert if tz-aware."""
    ts = pd.to_datetime(ts_raw, errors="coerce", dayfirst=True)
    if ts.isna().all():
        raise ValueError("Could not interpret timestamp fields (timestamp/Date+Time).")
    if getattr(ts.dt, "tz", None) is None:
        ts = ts.dt.tz_localize(TZ)
    else:
        ts = ts.dt.tz_convert(TZ)
    return ts

def normalize_type(val: str) -> str:
    """Normalize transaction types to known set + aliases."""
    if pd.isna(val):
        return "OTHER"
    v = str(val).strip().upper()
    aliases = {
        "P2P_INTERNATIONAL": "P2P_IN_INTL",
        "P2P_INTERNAT": "P2P_IN_INTL",
        "AIR TIME": "AIRTIME",
        "CASH IN": "CASHIN",
        "B2W ": "B2W",
        "B2 WALLET": "B2W"
    }
    v = aliases.get(v, v)
    return v if v in TX_TYPES else "OTHER"

def process_csv_activity(df: pd.DataFrame, freq_label: str) -> Dict[str, object]:
    """Build complete index + binary activity at chosen granularity."""
    freq = map_freq_label(freq_label)
    ts_col = next((c for c in df.columns if c.lower().strip() == "timestamp"), None)

    if ts_col:
        ts = _parse_timestamp_series(df[ts_col].astype(str).str.strip())
    else:
        if not (("Date" in df.columns) and ("Time" in df.columns)):
            raise ValueError("Provide a 'timestamp' column OR both 'Date' and 'Time'.")
        ts_raw = df["Date"].astype(str).str.strip() + " " + df["Time"].astype(str).str.strip()
        ts = _parse_timestamp_series(ts_raw)

    tmin, tmax = ts.min(), ts.max()
    tmin_floor, tmax_ceil = tmin.floor(freq), tmax.ceil(freq)
    full_index = pd.date_range(start=tmin_floor, end=tmax_ceil, freq=freq, tz=ts.dt.tz)

    bucketed = ts.dt.floor(freq).value_counts().reindex(full_index, fill_value=0).sort_index()
    binary = (bucketed > 0).astype(int)

    return {
        "df": df, "ts": ts, "full_index": full_index, "binary": binary,
        "tmin_floor": tmin_floor, "tmax_ceil": tmax_ceil, "freq": freq
    }

def get_binary_activity_stats(binary: pd.Series, tmin_floor: pd.Timestamp, tmax_ceil: pd.Timestamp, freq_label: str):
    total_slots = binary.size
    active_slots = int(binary.sum())
    return {
        "period": f"{tmin_floor.strftime('%Y-%m-%d %H:%M')} â†’ {tmax_ceil.strftime('%Y-%m-%d %H:%M')}",
        "granularity": freq_label,
        "total_slots": total_slots,
        "active_slots": active_slots,
        "inactive": total_slots - active_slots
    }

# ======================
# Viz: heatmaps & stacked histogram by type
# ======================
def build_binary_heatmap_figure(binary, full_index, freq, freq_label, tmin_floor, tmax_ceil):
    data = binary.values.reshape(1, -1)
    ticks_target = 8
    step = max(1, data.shape[1] // ticks_target)
    xticks_idx = np.arange(0, data.shape[1], step) if data.shape[1] else np.array([0])
    xticks_datetime = [full_index[i] for i in xticks_idx]
    xticklabels = [dt.strftime("%Y-%m-%d\n%H:%M") for dt in xticks_datetime]
    if freq == "D":
        xticklabels = [dt.strftime("%Y-%m-%d") for dt in xticks_datetime]

    fig = go.Figure(
        data=go.Heatmap(
            z=data, x=list(full_index), y=["Activity"],
            colorscale=[[0, "#C7C7C7"], [1, "#2ECC71"]],
            showscale=False, zmin=0, zmax=1,
            hovertemplate="Period: %{x|%Y-%m-%d %H:%M}<br>Status: %{z}<extra></extra>",
            xgap=1
        )
    )
    fig.update_layout(
        height=140, margin=dict(l=0, r=0, t=40, b=0),
        title=f"Binary activity ({freq_label}) from {tmin_floor.strftime('%Y-%m-%d %H:%M')} to {tmax_ceil.strftime('%Y-%m-%d %H:%M')}",
        xaxis=dict(tickmode="array", tickvals=xticks_datetime, ticktext=xticklabels, tickfont=dict(size=10)),
        yaxis=dict(visible=False),
    )
    return fig, xticks_idx, xticks_datetime, xticklabels

def build_type_heatmap_figure(df, ts, freq, full_index, xticks_idx, xticklabels, col_type):
    if not col_type:
        return None

    df_types = df.copy()
    df_types["slot"] = ts.dt.floor(freq)
    grouped = df_types.groupby([col_type, "slot"]).size().unstack(fill_value=0)

    type_matrix = np.zeros((len(TX_TYPES), len(full_index)), dtype=int)
    for i, typ in enumerate(TX_TYPES):
        if typ in grouped.index:
            vals = grouped.loc[typ].reindex(full_index, fill_value=0)
            type_matrix[i, :] = (vals > 0).astype(int)

    fig2 = go.Figure()
    for i, typ in enumerate(TX_TYPES):
        fig2.add_trace(go.Heatmap(
            z=[type_matrix[i]], x=full_index, y=[typ],
            showscale=False, colorscale=[[0, COLOR_EMPTY], [1, TX_COLORS[typ]]],
            zmin=0, zmax=1,
            hovertemplate=f"Type: {typ.replace('_',' ')}<br>Period: %{{x|%Y-%m-%d %H:%M}}<br>Presence: %{{z}}<extra></extra>"
        ))
    fig2.update_layout(
        height=38 * len(TX_TYPES) + 70, margin=dict(l=0, r=0, t=34, b=10),
        title="Transaction heatmap by type",
        xaxis=dict(tickmode="array", tickvals=[full_index[i] for i in xticks_idx], ticktext=xticklabels, tickfont=dict(size=10)),
        yaxis=dict(tickmode="array", tickvals=TX_TYPES, ticktext=[t.replace('_', ' ') for t in TX_TYPES], tickfont=dict(size=11))
    )
    return fig2

def build_stacked_histogram(counts, x_col, type_col):
    fig3 = px.bar(
        counts, x=x_col, y="n", color=type_col,
        category_orders={type_col: TX_TYPES}, color_discrete_map=TX_COLORS
    )
    fig3.update_layout(
        barmode="stack", title="Stacked histogram of transactions by type",
        xaxis_title="Period", yaxis_title="Number of transactions",
        margin=dict(l=0, r=0, t=50, b=0)
    )
    return fig3

# ======================
# Viz: readable Balance (top) + Flows (bottom) panel
# ======================
def _find_type_col(df: pd.DataFrame) -> Optional[str]:
    return next((c for c in df.columns if c.lower() == "type"), None)

def _find_solde_col(df: pd.DataFrame) -> Optional[str]:
    # Keep French column name 'solde' if thatâ€™s what your CSV uses
    return next((c for c in df.columns if c.strip().lower() == "solde"), None)

def _find_amount_col(df: pd.DataFrame) -> Optional[str]:
    # Accept both English and French for convenience
    cands = [c for c in df.columns if c.strip().lower() in {"amount", "montant", "value", "valeur", "sum", "total"}]
    return cands[0] if cands else None

def build_balance_panel(
    full_index: pd.DatetimeIndex,
    ts: pd.Series,
    df: pd.DataFrame,
    col_type: Optional[str],
    col_solde: Optional[str],
    xticks_datetime: List[pd.Timestamp]
) -> Optional[go.Figure]:
    """
    Two vertically stacked subplots (shared X):
      - Row 1: Balance (cyan line) + 7-day moving average (dotted)
      - Row 2: Daily bars (green = inflows, red = outflows)
        -> Sums of amounts if an amount column exists, otherwise counts
    Independent, controlled scales (98th pct cap for bars, 5% padding for balance).
    """
    if (col_type is None) and (col_solde is None):
        return None

    # --- Daily balance (last value per day + forward-fill)
    balance_series = None
    if col_solde is not None:
        day_slots = ts.dt.floor("D")
        balance_num = pd.to_numeric(df[col_solde], errors="coerce")
        balance_series = (
            pd.DataFrame({"slot": day_slots, "balance": balance_num})
            .groupby("slot")["balance"]
            .agg(lambda s: s.dropna().iloc[-1] if not s.dropna().empty else np.nan)
            .reindex(full_index)
            .ffill()
        )
        balance_mm7 = balance_series.rolling(7, min_periods=1).mean()
    else:
        balance_mm7 = None

    # --- Daily flows
    in_vals = out_vals = None
    y_bars_title = ""
    if col_type is not None:
        day_slots = ts.dt.floor("D")
        amount_col = _find_amount_col(df)
        typed = df[col_type]

        if amount_col:
            amt = pd.to_numeric(df[amount_col], errors="coerce").fillna(0.0)
            df_tx = pd.DataFrame({"slot": day_slots, "type": typed, "amount": amt})
            in_series = (
                df_tx[df_tx["type"].isin(IN_TYPES)]
                .groupby("slot")["amount"].sum()
                .reindex(full_index, fill_value=0.0)
            )
            out_series = (
                df_tx[df_tx["type"].isin(OUT_TYPES)]
                .groupby("slot")["amount"].sum()
                .reindex(full_index, fill_value=0.0)
            )
            in_vals  = in_series.values
            out_vals = -np.abs(out_series.values)
            y_bars_title = "Daily amounts (inflows + / outflows -)"
        else:
            in_series = (
                pd.Series(1, index=day_slots[typed.isin(IN_TYPES)])
                .groupby(level=0).sum()
                .reindex(full_index, fill_value=0)
            )
            out_series = (
                pd.Series(1, index=day_slots[typed.isin(OUT_TYPES)])
                .groupby(level=0).sum()
                .reindex(full_index, fill_value=0)
            )
            in_vals  = in_series.values.astype(float)
            out_vals = -out_series.values.astype(float)
            y_bars_title = "Number of transactions (inflows + / outflows -)"

    # --- Figure: 2 synchronized rows
    fig = make_subplots(
        rows=2, cols=1, shared_xaxes=True,
        vertical_spacing=0.08,
        row_heights=[0.55, 0.45],
        subplot_titles=("Balance (daily)", "Daily flows (inflows / outflows)")
    )

    # Row 1: Balance
    if balance_series is not None:
        # soft halo
        fig.add_trace(
            go.Scatter(
                x=full_index, y=balance_series.values,
                mode="lines", name="Balance (halo)",
                line=dict(color="rgba(255,255,255,0.15)", width=6),
                hoverinfo="skip",
            ),
            row=1, col=1
        )
        # main line
        fig.add_trace(
            go.Scatter(
                x=full_index, y=balance_series.values,
                mode="lines", name="Balance",
                line=dict(color="#00E5FF", width=2.5),
                hovertemplate="Date: %{x|%Y-%m-%d}<br>Balance: %{y:,.2f}<extra></extra>",
            ),
            row=1, col=1
        )
        # 7-day MA
        fig.add_trace(
            go.Scatter(
                x=full_index, y=balance_mm7.values,
                mode="lines", name="Balance (7-day MA)",
                line=dict(color="#00E5FF", width=1.5, dash="dot"),
                hovertemplate="Date: %{x|%Y-%m-%d}<br>Balance (MA7): %{y:,.2f}<extra></extra>",
            ),
            row=1, col=1
        )

    # Row 2: Bars
    if col_type is not None:
        fig.add_trace(
            go.Bar(
                x=full_index, y=in_vals,
                name="Inflows", marker_color=GREEN_IN, opacity=0.6,
                hovertemplate="Date: %{x|%Y-%m-%d}<br>Inflows: %{y:,.2f}<extra></extra>",
            ),
            row=2, col=1
        )
        fig.add_trace(
            go.Bar(
                x=full_index, y=out_vals,
                name="Outflows", marker_color=RED_OUT, opacity=0.6,
                customdata=np.abs(out_vals),
                hovertemplate="Date: %{x|%Y-%m-%d}<br>Outflows: %{customdata:,.2f}<extra></extra>",
            ),
            row=2, col=1
        )

        # Symmetric scale capped at 98th percentile
        bars_abs = np.abs(np.concatenate([in_vals, out_vals])).astype(float)
        finite = bars_abs[np.isfinite(bars_abs)]
        cap = np.nanpercentile(finite, 98) if finite.size else 1.0
        cap = max(cap, 1.0)
        fig.update_yaxes(range=[-cap*1.1, cap*1.1], row=2, col=1, zeroline=True, title_text=y_bars_title)

    # Balance scale with 5% padding
    if balance_series is not None:
        smin = float(np.nanmin(balance_series.values))
        smax = float(np.nanmax(balance_series.values))
        pad = (smax - smin) * 0.05 if np.isfinite(smax - smin) else 1.0
        fig.update_yaxes(range=[smin - pad, smax + pad], row=1, col=1, title_text="Balance")

    # Layout
    fig.update_layout(
        title="Balance & daily flows (readable view)",
        margin=dict(l=0, r=0, t=60, b=0),
        legend=dict(orientation="h", yanchor="bottom", y=1.04, xanchor="right", x=1),
        hovermode="x unified",
    )
    # Synchronized ticks + range slider
    fig.update_xaxes(
        tickmode="array",
        tickvals=xticks_datetime,
        ticktext=[dt.strftime("%Y-%m-%d") for dt in xticks_datetime],
        rangeslider=dict(visible=True),
        row=2, col=1
    )
    fig.update_xaxes(showgrid=False, row=1, col=1)

    return fig

# ======================
# UI Helpers
# ======================
def render_sidebar() -> Tuple[bool, bool, bool]:
    with st.sidebar:
        st.header("Settings")
        show_types = st.toggle("Show type heatmap", value=True)
        show_hist  = st.toggle("Show stacked histogram (types)", value=True)
        demo       = st.toggle("Demo mode (no CSV)", value=False)
    return show_types, show_hist, demo

def render_stats(binary, tmin_floor, tmax_ceil, freq_label):
    stats = get_binary_activity_stats(binary, tmin_floor, tmax_ceil, freq_label)
    st.caption(
        f"**Period**: {stats['period']} â€¢ **Granularity**: {stats['granularity']} â€¢ "
        f"**Active**: {stats['active_slots']}/{stats['total_slots']} â€¢ **Inactive**: {stats['inactive']}"
    )

def _make_demo_df(n=300, start="2025-09-01 08:00", freq="1H") -> pd.DataFrame:
    """Small demo dataset to test the UI without a CSV."""
    rng = pd.date_range(start=start, periods=n, freq=freq)
    mask = np.random.rand(n) < 0.35
    ts = rng[mask]
    types = np.random.choice(TX_TYPES, size=ts.size, p=[0.2,0.05,0.07,0.1,0.15,0.1,0.1,0.03,0.05,0.15])
    balance = 100000 + np.cumsum(np.random.randn(ts.size) * 1000).astype(float)
    amount = np.random.lognormal(mean=9.5, sigma=0.8, size=ts.size).astype(float)
    return pd.DataFrame({"timestamp": ts, "type": types, "solde": balance, "amount": amount})

# ======================
# Main
# ======================
def main():
    st.set_page_config(page_title="Binary Activity Heatmap", page_icon="ðŸŸ©", layout="wide")
    st.title("ðŸŸ© Horizontal Activity Heatmap (gray = inactive, green = active)")
    st.markdown("The CSV can contain **`timestamp`** or **`Date` + `Time`**. `solde` (balance) and `amount/montant` are optional.")

    uploaded = st.file_uploader("ðŸ“‚ Upload CSV file", type=["csv"])
    show_types, show_hist, demo = render_sidebar()

    # Fixed granularity: 24h (1D)
    freq_label = "1D"

    if not uploaded and not demo:
        st.info("â¬†ï¸ Upload a CSV or enable **Demo mode** in the sidebar.")
        return

    try:
        if demo and not uploaded:
            df = _make_demo_df()
        else:
            df = read_csv_smart(uploaded)

        # Normalize 'type' if present
        col_type = _find_type_col(df)
        if col_type:
            df[col_type] = df[col_type].apply(normalize_type)

        # Activity (1D)
        result = process_csv_activity(df, freq_label)
        binary, full_index = result["binary"], result["full_index"]
        tmin_floor, tmax_ceil, freq, ts = result["tmin_floor"], result["tmax_ceil"], result["freq"], result["ts"]

        # Stats + main heatmap
        render_stats(binary, tmin_floor, tmax_ceil, freq_label)
        fig, xticks_idx, xticks_datetime, xticklabels = build_binary_heatmap_figure(
            binary, full_index, freq, freq_label, tmin_floor, tmax_ceil
        )
        st.plotly_chart(fig, use_container_width=True)

        # Heatmap by type (optional)
        if show_types:
            if col_type:
                fig2 = build_type_heatmap_figure(df, ts, freq, full_index, xticks_idx, xticklabels, col_type)
                st.plotly_chart(fig2, use_container_width=True)
            else:
                st.info("`type` column missing: type heatmap not displayed.")

        # Stacked histogram (optional)
        if show_hist and col_type:
            df_hist = pd.DataFrame({"slot": ts.dt.floor(freq)})
            df_hist[col_type] = df[col_type]
            counts = (
                df_hist.groupby(["slot", col_type]).size().reset_index(name="n")
                .set_index(["slot", col_type])
                .reindex(pd.MultiIndex.from_product([full_index, TX_TYPES], names=["slot", col_type]), fill_value=0)
                .reset_index()
            )
            fig3 = build_stacked_histogram(counts, "slot", col_type)
            fig3.update_xaxes(tickmode="array", tickvals=xticks_datetime, ticktext=[dt.strftime("%Y-%m-%d") for dt in xticks_datetime])
            st.plotly_chart(fig3, use_container_width=True)

        # Balance (top) + Flows (bottom) panel
        col_solde = _find_solde_col(df)  # still looks for French 'solde' column in your CSV
        fig_panel = build_balance_panel(
            full_index=full_index, ts=ts, df=df,
            col_type=col_type, col_solde=col_solde,
            xticks_datetime=xticks_datetime
        )
        if fig_panel is not None:
            st.plotly_chart(fig_panel, use_container_width=True)
        else:
            st.info("Neither `type` nor `solde` found: flows panel not displayed.")

    except Exception as e:
        st.error(f"âŒ Error: {e}")

if __name__ == "__main__":
    main()
